---
title: "Costomer Churn Data analysis"
author: "Amalawa ogbomo"
date: "24/03/2021"
output: html_document

---

```{r}
#Step1 import the csv file as churn in a csv format and import the appropriate packages and libraries 
#install.packages("readr")
library(readr)
#install.packages("data.table")
library(data.table)
churn<-read.csv("C:/Users/aoogb/Desktop/DAT7005Dataset.csv", stringsAsFactors = TRUE)
churn<-as.data.frame(churn)
churn
str(churn)
colnames(churn)
#10127 observations
#23 variables 

#install.packages("")

#step 2  Data Cleaning 
#step2a install the packages and libraries 
#install.packages("tibble")
library(tibble)
#install.packages("Hmisc")
library(Hmisc)
#install.packages("tidyverse")
library(tidyverse)
#install.packages("tidyr")
library(tidyr)
#install.packages("dplyr")
library(dplyr)

#step2b;drop columns CLIENTNUM that do not  contribute to the target column and
# columns CLIENTNUM is droped 
churn <- subset(churn[, c(2:23)])
churn
colnames(churn)
#step 2c converting the unknow values to missing values or null values represented as NA 
churn[churn=="Unknown"] <-""
churn
for(i in colnames(churn)){
    print(sum(is.na(churn[[i]])))
}
#count of missing values in different columns 
str(churn$Education_Level)
#[5] "Education_Level" = 1519  
str(churn$Marital_Status)
#[6] "Marital_Status"=  749 
 str(churn$Income_Category)
#[7] "Income_Category"= 1112 

# step 2d Handling missing values 
for(i in colnames(churn)){
    print(mean(is.na(churn[[i]])))
}
# because all the mean is greater than 0.05 we drop the rows with the missing values 
# [5] "Education_Level"= 0.1499951                                                                                                                  
# [6] "Marital_Status"= 0.0739607                                                                                                                 
# [7] "Income_Category"= 0.1098055 

count_missingvalue<-sum(is.na(churn))
count_missingvalue
#total nmissing value is 3380
# to drop or delete the missing value 
churn<-na.omit(churn)
churn
```


```{r}
#Step 3 Constraining the categorical variables 
# column 1 target column Attrition_Flag column is constrained as 1 for Existing Customer and 2 for Attrited Customer
churn$Attrition_Flag
churn<-churn%>%mutate(Attrition_Flag=case_when(
    Attrition_Flag=="Existing Customer" ~ 1,
    Attrition_Flag=="Attrited Customer" ~ 2,
      ))
str(churn$Attrition_Flag)
churn$Attrition_Flag
# represent Existing Customer as 1, and Attrited Customer as 2 
# constraining the gender as M for 1 and F for 2 
churn$Gender
churn<-churn%>%mutate(Gender=case_when(
   Gender=="M" ~ 1,
   Gender=="F" ~ 2,))
str(churn$Gender)
churn$Gender
# constrain the educational level as 1 to 6 
churn$Education_Level
churn<-churn%>%mutate(Education_Level=case_when(
  Education_Level=="Uneducated"~ 1,
  Education_Level=="High School"~ 2,
  Education_Level=="College" ~ 3,
  Education_Level=="Post-Graduate"~4,
  Education_Level=="Graduate"~5,
  Education_Level=="Doctorate"~6,))
str(churn$Education_Level)
# constrain the Marital_Status as 1 to 3 
churn$Marital_Status
churn<-churn%>%mutate(Marital_Status=case_when(
 Marital_Status=="Single"~ 1,
 Marital_Status=="Married"~2,
 Marital_Status=="Divorced"~ 3,))
churn$Marital_Status
# constrain the Income_Category as 1 to 5 
churn$Income_Category
churn<-churn%>%mutate(Income_Category=case_when(
  Income_Category=="Less than $40K"~ 1,
  Income_Category=="$40K - $60K"~ 2,
  Income_Category=="$60K - $80K" ~ 3,
  Income_Category=="$80K - $120K"~4,
  Income_Category=="$120K +"~5,))
# constrain the Card_Category as 1 to 4 
churn$Card_Category
churn<-churn%>%mutate(Card_Category=case_when(
  Card_Category=="Blue"~ 1,
  Card_Category=="Gold"~ 2,
  Card_Category=="Platinum" ~ 3,
  Card_Category=="Silver"~4,))
churn$Card_Category
str(churn)
churn
```

## Including Plots








```{r}
#step4 Handling outliers 
for(i in colnames(churn)){
  print(boxplot.stats((churn[[i]]))$out)
}

#a. detecting outliers with a boxplot  
  for(i in colnames(churn)){
    print(boxplot(churn[[i]]))
}
 # from the above for loop codes above a boxplot and boxplot statistics is used to detect the outliers and the results are as follows 
#  [1] "Attrition_Flag" target columns outliers dismissed as outliers 

      boxplot.stats(churn$Customer_Age)$out # 70 and 73 years detected 
#  [2] "Customer_Age"  outlier detected from boxplot above                                                                                                                   
                                                                                                                           
                                                                                                                  
                                                                                                                   
#  [8] "Card_Category"# categorical variable outlier dissmised as outliers                                                                                                                    
#  [9] "Months_on_book" # outliers are present                                                                                                                    
# [11] "Months_Inactive_12_mon"   outliers are present                                                                                                         
# [12] "Contacts_Count_12_mon"    outliers are present                                                                                                         
# [13] "Credit_Limit"      outliers are dissmissed as boxplot mean and median is totally outside the clustered values to the top                                                                                                                 
                                                                                                               
# [15] "Avg_Open_To_Buy"  outliers are dissmissed as boxplot mean and median is totally outside the clustered values to the top                                                                                                                  
# [16] "Total_Amt_Chng_Q4_Q1"  outliers are dissmissed as boxplot mean and median is totally outside the clustered values to the top
      
# [17] "Total_Trans_Amt" outliers are dissmissed as boxplot mean and median is totally outside the clustered values to the top 
      
# 
      
# [19] "Total_Ct_Chng_Q4_Q1" # outliers are dissmissed as boxplot mean and median is totally outside the clustered values to the top                                                                                                               

      
      boxplot.stats(churn$Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1)$out
# [21] "Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1"
       #outliers dismisses as outliers as we can show from box plots as they are clustered around the top only 
      
      boxplot.stats(churn$Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2)$out
# [22] "Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2
   #outliers dismisses as outliers as we can show from box plots as boxplot mean and median are clustered around the bottom only. 
#b. Test for outliers
      
      
#install.packages("EnvStats")
library(EnvStats)

for(i in colnames(churn)){
    print(rosnerTest(churn[[i]]))
    
}



#d. we apply a function to balance the quantile with a lower boundry of 0.05 and upper boundry of 0.95
fun <- function(x){
  for(i in colnames(churn)){
    qn = quantile((churn[[i]]), c(0.05, 0.95), na.rm = TRUE)
churn = within(churn, { i = ifelse(i< qn[1], qn[1],i)
                   i= ifelse(i > qn[2], qn[2], i)})
  }
}
 
 

sapply(churn, fun)
```
```{r}
#step5 Data analysis of the different columns  

library(ISwR)
library(GGally)
library(cdata)
library(wrapr)
library(ggpubr)
library(ggrepel)
library(grDevices)
library(ggbiplot)
library(ggplot2)

churn$Attrition_Flag<-as.factor(churn$Attrition_Flag)
ggplot(churn, 
       aes(x = Attrition_Flag, 
           y = ..count.. / sum(..count..))) + 
  geom_bar() +
  geom_bar(fill = "#0073C2FF") +
  labs(x = "Existing Customer 1 and Attrited Customer 2", 
       y = "Percentage of Existing Customer or Attrited Customer", 
       title  = "% Existing Customer or Attrited Customer of Attrition_Flag") +
  scale_y_continuous(labels = scales::percent)

plotdata<-churn%>%
  dplyr::count(Attrition_Flag) %>%
  mutate(pct = n / sum(n),
         pctlabel = paste0(round(pct*100), "%"))
plotdata

ggplot(plotdata, 
       aes(x = reorder(Attrition_Flag, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = "indianred3", 
           color = "black") +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  scale_y_continuous(labels = percent) +
  labs(x = "Existing Customer 1 and Attrited Customer 2 ", 
        y = "Percentage of Existing Customer or Attrited Customer",
        title  = "% Existing Customer or Attrited Customer of Attrition_Flag")

#Data Analysis of other features against the target categorical variable 
#using a bar plot 
churn
describe(churn)
 #the idea is to loop through our dataset and get a visualization of the analysis of the barpot to the target feature 

Churn_numeric<-dplyr::select(churn,-Gender,-Dependent_count,-Education_Level,-Marital_Status,-Income_Category,-Card_Category,-Total_Relationship_Count,-Months_Inactive_12_mon,-Contacts_Count_12_mon)
Churn_numeric

summary(Churn_numeric)
Churn_numeric[]<- lapply(Churn_numeric, function(m) {
  if(!is.numeric(m)|is.integer(m)) as.numeric(as.character(m)) else m
 })
sapply(Churn_numeric, class)
 
str(Churn_numeric)


churn_categorical<-dplyr::select(churn,Attrition_Flag,Gender,Dependent_count,Education_Level,Marital_Status,Income_Category,Card_Category,Total_Relationship_Count,Months_Inactive_12_mon,Contacts_Count_12_mon)
#churn_categorical<-as.factor(churn_categorical)
churn_categorical[]<- lapply(churn_categorical, function(b){
  if(is.numeric(b)|is.integer(b)) as.factor(b) else b
 })
sapply(churn_categorical, class)
 
str(churn_categorical)
churn_categorical

#barplot for categorical variables 
 for (i in colnames(churn_categorical)){
    plot <- ggplot(churn_categorical, 
       aes_string(x = i, 
           fill = churn_categorical[[1]], group =churn_categorical[[1]])) + 
  geom_bar(position = position_dodge(preserve = "single"))+
  ggtitle(i)
  geom_point()
  print(plot)
 }

#barplot for numerical variables 
Churn_numeric
 for (i in colnames(Churn_numeric)){
    plot <- ggplot(Churn_numeric, 
       aes_string(x = i, 
           fill = Churn_numeric[[1]], group =Churn_numeric[[1]])) + 
  geom_bar(position = position_dodge(preserve = "single"))+
  scale_x_continuous(breaks=seq(0,max((x),1)))
  #scale_y_continuous(breaks=seq(0,max(table(x)),1))
  geom_point()
  print(plot)
 }



for (i in colnames(Churn_numeric)){
    plot <- ggplot(Churn_numeric, aes_string(x=i, y=Churn_numeric[[1]])) +
    geom_point()+
      ggtitle(i)
    print(plot)
 }

 for(i in colnames(Churn_numeric)){
  print(ggdensity((Churn_numeric[[i]]))+
       ggtitle(i))

 }

  myPlots <- function(data, column, fill_color) {
  # column = character name of column
  p <- ggplot(data, aes_string(x=column)) +
    geom_histogram(fill='red', binwidth=1, alpha=0.5, color='black') +
    scale_x_continuous(breaks=seq(floor(min(data[column])), ceiling(max(data[column])),1)) +
    ggtitle(column)
  
  max_count <- max(ggplot_build(p)$data[[1]]$count)
  p <- p + scale_y_continuous(breaks=seq(0,max_count,1))
  return(p)
}

library(cowplot)

plotList <- lapply(names(Churn_numeric), myPlots, data=Churn_numeric)
plot_grid(plotlist = plotList)
Churn_numeric

for (i in 1:ncol(Churn_numeric)) {
  p <- ggplot(Churn_numeric, aes(Churn_numeric[,i],fill = Churn_numeric[[1]], group =Churn_numeric[[1]])) +
    geom_histogram(alpha=0.5, binwidth=1) +
    scale_x_continuous(breaks=seq(floor(min(Churn_numeric[,i])),ceiling(max(Churn_numeric[,i])))) +
    ggtitle(names(Churn_numeric)[i])
  
  # get max counts
  max_count <- max(ggplot_build(p)$data[[1]]$count)
  p <- p + scale_y_continuous(breaks=seq(0,max_count,1)) 

  print(p)
}
for(i in colnames(Churn_numeric)){
  print(ggdensity((Churn_numeric[[i]]), 
          main = "Density plot"))
}
 Churn_numeric
```

```{r}
#step6 .correlation analysis  , relationship between the Attrition_Flag target column and the other columns.
library(corrplot)
library(ggcorrplot)


 summary(churn)
 churn[]<- lapply(churn, function(x) {
  if(!is.numeric(x)|is.integer(x)) as.numeric(as.character(x)) else x
 })
sapply(churn, class)
 
str(churn)


table(churn$Attrition_Flag)
pairs(churn)
correlations=cor(churn,churn$Attrition_Flag,method = "spearman")
correlations 
plot(correlations)
corrplot(correlations, Attrition_Flagber.cex =1, method = "circle", type = "full", tl.cex=.8,tl.col = "black")
churnmatrix<-as.matrix(churn)
Corelationmatrix<-rcorr(churnmatrix)
Corelationmatrix
# Extract the correlation coefficients
Corelationmatrix$r
correlationcoef<-as.data.frame(Corelationmatrix$r)
correlationcoef$Attrition_Flag<-as.matrix(correlationcoef$Attrition_Flag)
correlationcoef$Attrition_Flag
# Extract p-values
Corelationmatrix$P 
Pvalue<-as.data.frame(Corelationmatrix$P )
Pvalue$Attrition_Flag<-as.matrix(Pvalue$Attrition_Flag)
Pvalue$Attrition_Flag

correlation_correlationcoef_Pvalue<-cbind(correlations,correlationcoef$Attrition_Flag,Pvalue$Attrition_Flag) 
correlation_correlationcoef_Pvalue
#correlation_correlationcoef_Pvalue<-data.frame(correlation_correlationcoef_Pvalue)
#correlation_correlationcoef_Pvalue
## visualize correlations and density plot and eclipes 
#install.packages("psych")
library(psych)
pairs.panels(churn[,-1], 
             method = "spearman", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
str(churn)
```

```{r}
#step 7
m<-Churn_numeric[2:13]
m
for(i in colnames(m)){
 # x <- Churn_numeric[2:12][,i]
 plt<-ggplot(Churn_numeric, mapping = aes_string(x="Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2", y = m[ , i])) +
 scale_x_continuous(breaks=seq(0,max((x),1)))+scale_y_continuous(breaks=seq(0,max(table(x)),1))+
geom_bar(stat='identity') + ggtitle(paste(i, "nbayes model scattered plot", sep=" - 
")) 
  print(plt)
  ggsave(paste0(i,".png"))
  Sys.sleep(2)
}
str(Churn_numeric)
colnames(Churn_numeric)

m<-Churn_numeric[1:13]
m
for(i in colnames(m)) {                              # Printing ggplot within for-loop
  print(ggplot(m, aes(x = Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2, y = m[ , i],fill = m[[1]], group =m[[1]])) +
          geom_point())
  Sys.sleep(2)
}
ChurnData
```






